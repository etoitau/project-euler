# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal 
# numbers are all figurate (polygonal) numbers and are generated by 
# the following formulae:
# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 	        1, 4, 9, 16, 25, ...
# Pentagonal	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, 
# has three interesting properties.
# The set is cyclic, in that the last two digits of each number is 
# the first two digits of the next number 
# (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), 
# and pentagonal (P5,44=2882), is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers 
# for which each polygonal type: triangle, square, pentagonal, 
# hexagonal, heptagonal, and octagonal, is represented by a different number 
# in the set
# Result: 28684

import math
from typing import Set, List, Tuple, Dict
import time
import sys
sys.path.append(".")
from util import ngonal_inverse, nth_ngonal, permute
import os

__location__ = os.path.realpath(
    os.path.join(os.getcwd(), os.path.dirname(__file__)))

def ngonals_with_prefix(pre: int, ngon: int) -> List[int]:
    """ Return all the four-digit figurate numbers of the order 
    ngon that have the given two-digit prefix
    """
    if pre < 10:
        # Not a two digit prefix
        return []
    find = pre * 10 * 10
    limit = find + 99
    # Jump to the first match
    i = math.ceil(ngonal_inverse(find, ngon))
    result = []
    while True:
        # Add subsequent until prefix no longer matches
        num = nth_ngonal(i, ngon)
        if num > limit:
            return result
        result.append(num)
        i += 1

def suffix(n: int) -> int:
    return n % 100

def prefix(n: int) -> int:
    return n // 100

def solve(max_ngon: int) -> int:
    """ Solve the problem for a given max figurate number order
    As stated this is 8, but 5 is givin as an example.
    """
    # Find all the figurate numbers of order max_ngon which are four digits
    four_digit_start = []
    st = 1000
    end = 9999
    i = math.ceil(ngonal_inverse(st, max_ngon))
    while True:
        t = nth_ngonal(i, max_ngon)
        if t > end:
            break
        if t > st:
            four_digit_start.append(t)
        i += 1
    # We're starting with the largest and trying to chain on the others
    others = [ n for n in range(3, max_ngon) ]
    # Those others could be in any order, so check each permutation
    for rest_order in permute(others):
        order = [max_ngon] + rest_order
        for fds in four_digit_start:
            # For each start, try to build a chain matching the given order
            chain = helper([fds], order)
            # If chain has full length, signifies success
            if len(chain) == len(others) + 1:
                return sum(chain)
    return 0

def helper(so_far: List[int], order: List[int]) -> List[int]:
    """ Recursive function to do dfs for possible chains """
    for match in ngonals_with_prefix(suffix(so_far[-1]), order[len(so_far)]):
        new_so_far = so_far + [match]
        if len(new_so_far) == len(order):
            # If chain is now complete, check if end connects to start
            return new_so_far if suffix(new_so_far[-1]) == prefix(new_so_far[0]) \
                else []
        path = helper(new_so_far, order)
        if len(path) == len(order):
            # If a solution was found, pass it up recursion stack
            return path
    return []
    
if __name__ == '__main__':
    """starts here"""
    start = time.time()
    for p in permute([0, 1, 2]):
        print(p)
    # print(solve(8)) # 28684
    print(time.time() - start) # 0.007 sec
